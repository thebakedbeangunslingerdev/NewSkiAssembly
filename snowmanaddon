; ski_snowman.asm - Real-time NewSkiAssembly clone with Abomonal Snowman
; Assemble: nasm -f elf32 ski_snowman.asm
; Link: ld -m elf_i386 -s -o ski_snowman ski_snowman.o
; Run: ./ski_snowman

section .data
    clear_screen db 27,'[2J',27,'[H',0
    newline db 10,0
    skier_char db 'A'
    tree_char db 'T'
    snowman_char db 'S'
    prompt db 'Score: ',0
    width equ 30
    height equ 20
    tree_count equ 20

section .bss
    skierX resb 1
    score resd 1
    trees resb tree_count*2 ; x,y positions for each tree
    key resb 1
    snowmanX resb 1
    snowmanY resb 1
    snowmanActive resb 1

section .text
global _start

_start:
    ; initialize skier
    mov byte [skierX], width/2
    mov dword [score], 0
    mov byte [snowmanActive], 0  ; inactive at start

    ; initialize trees
    mov ecx, tree_count
    mov esi, trees
.init_trees:
    mov eax, 0
    call rand
    xor edx, edx
    mov ebx, width
    div ebx
    mov [esi], al
    inc esi
    mov eax, 0
    call rand
    xor edx, edx
    mov ebx, height
    div ebx
    mov [esi], al
    inc esi
    loop .init_trees

game_loop:

    ; 1. clear screen
    mov eax, 4
    mov ebx, 1
    mov ecx, clear_screen
    mov edx, 7
    int 0x80

    ; 2. draw trees
    mov ecx, tree_count
    mov esi, trees
.draw_trees:
    movzx eax, byte [esi]    ; x
    mov edx, eax
    inc esi
    movzx eax, byte [esi]    ; y
    inc esi
    mov eax, 4
    mov ebx, 1
    mov ecx, tree_char
    mov edx, 1
    int 0x80
    loop .draw_trees

    ; 3. draw snowman if active
    cmp byte [snowmanActive], 0
    je .skip_snowman
    mov al, [snowmanX]
    mov eax, 4
    mov ebx, 1
    mov ecx, snowman_char
    mov edx, 1
    int 0x80
.skip_snowman:

    ; 4. draw skier
    mov al, [skierX]
    mov eax, 4
    mov ebx, 1
    mov ecx, skier_char
    mov edx, 1
    int 0x80

    ; 5. print score
    mov eax, 4
    mov ebx, 1
    mov ecx, prompt
    mov edx, 7
    int 0x80

    ; 6. spawn snowman if score >= 10
    mov eax, [score]
    cmp eax, 10
    jl .skip_spawn
    cmp byte [snowmanActive], 1
    je .skip_spawn
    call spawn_snowman
.skip_spawn:

    ; 7. input (non-blocking)
    mov eax, 3
    mov ebx, 0
    mov ecx, key
    mov edx, 1
    int 0x80
    cmp byte [key], 'a'
    jne .check_d
    ; move left
    mov al, [skierX]
    cmp al, 0
    je .skip_left
    dec byte [skierX]
.skip_left:
.check_d:
    cmp byte [key], 'd'
    jne .skip_right
    mov al, [skierX]
    cmp al, width-1
    jae .skip_right
    inc byte [skierX]
.skip_right:

    ; 8. update trees
    mov ecx, tree_count
    mov esi, trees
.update_trees:
    inc byte [esi+1] ; y++
    cmp byte [esi+1], height
    jl .no_wrap
    mov byte [esi+1], 0
    inc dword [score]
.no_wrap:
    add esi, 2
    loop .update_trees

    ; 9. update snowman
    cmp byte [snowmanActive], 0
    je .skip_update
    inc byte [snowmanY]   ; moves faster than trees
    cmp byte [snowmanY], height
    jl .no_wrap_snowman
    mov byte [snowmanY], 0
.no_wrap_snowman:
    ; random horizontal shift
    call rand
    and al, 1
    cmp al, 0
    je .no_shift
    mov al, [snowmanX]
    cmp al, width-2
    jae .no_shift
    inc byte [snowmanX]
    jmp .done_shift
.no_shift:
    mov al, [snowmanX]
    cmp al, 1
    jbe .done_shift
    dec byte [snowmanX]
.done_shift:

.skip_update:

    ; 10. check collisions - trees
    mov ecx, tree_count
    mov esi, trees
.check_tree_collision:
    mov al, [esi]
    mov bl, [esi+1]
    mov dl, [skierX]
    cmp bl, height-1
    jne .next_tree
    cmp al, dl
    jne .next_tree
    jmp .game_over
.next_tree:
    add esi, 2
    loop .check_tree_collision

    ; 11. check collisions - snowman
    cmp byte [snowmanActive], 0
    je .skip_snowman_collision
    mov al, [skierX]
    mov bl, [snowmanX]
    cmp al, bl
    jne .skip_snowman_collision
    mov al, height-1
    cmp byte [snowmanY], al
    jne .skip_snowman_collision
    jmp .game_over
.skip_snowman_collision:

    ; 12. delay
    mov ecx, 7000000
.delay:
    loop .delay

    jmp game_loop

.game_over:
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, 1
    int 0x80

    mov eax, 1
    mov ebx, 0
    int 0x80

; ---------------------------
; spawn snowman at random x
spawn_snowman:
    call rand
    xor edx, edx
    mov ebx, width
    div ebx
    mov [snowmanX], al
    mov byte [snowmanY], 0
    mov byte [snowmanActive], 1
    ret

; ---------------------------
; simple rand function
rand:
    mov eax, 0
    rdtsc
    xor edx, edx
    mov al, dl
    ret
